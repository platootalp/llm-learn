# 软件架构模式

![](img\software-architecture-styles.png)

## 1 分层架构（Layered Architecture）

**核心思想**
 将系统划分为若干水平分层，每层只与相邻层交互，职责清晰、解耦明确。

**结构**

- 表示层（UI）
- 应用层（业务流程）
- 领域层（业务逻辑）
- 基础设施层（数据库、网络等）

**优点**

- 分层清晰，职责明确
- 易于开发、测试与维护
- 便于团队协作

**缺点**

- 可能造成性能瓶颈（层层传递）
- 灵活性不足，改动一层影响链条长

**适用场景**

- 传统企业应用系统（如ERP、CRM）
- 系统规模适中，需求清晰



## 2 微内核架构（Microkernel Architecture）

**核心思想**
 构建一个可扩展的核心系统，通过插件扩展功能，核心负责最小职责。

**结构**

- 核心模块（内核）
- 插件模块（功能扩展）
- 插件通信机制

**优点**

- 灵活可扩展
- 插件可独立部署、升级
- 核心系统稳定性高

**缺点**

- 插件管理复杂
- 插件间耦合控制难度大

**适用场景**

- IDE（如 IntelliJ、Eclipse）
- 浏览器（如 Chrome 插件系统）
- 轻量级可插拔系统



## 3 微服务架构（Microservices Architecture）

**核心思想**
 将系统划分为多个小型、自治的服务，每个服务聚焦于特定业务能力，通过 API 通信协作。

**结构**

- 服务A / 服务B / 服务C（自治）
- API 网关
- 服务注册中心
- 配置中心、链路追踪等配套设施

**优点**

- 服务自治，独立部署与扩展
- 技术栈灵活、团队并行开发
- 故障隔离性强

**缺点**

- 架构复杂度高（DevOps、治理）
- 服务间通信成本高
- 一致性难处理

**适用场景**

- 大型互联网系统
- 快速迭代、模块解耦需求强



## 4 基于空间的架构（Space-Based Architecture）

**核心思想**
 通过分布式内存数据网格（IMDG）避免数据库成为瓶颈，系统组件共享“空间”通信。

**结构**

- Processing Units（计算单元）
- Data Grid（共享内存）
- Messaging Grid（事件通道）

**优点**

- 极高的可扩展性与可用性
- 减少数据库压力
- 弹性好，适合云原生部署

**缺点**

- 学习曲线陡峭
- 一致性处理复杂
- 开发测试难度高

**适用场景**

- 高频交易平台
- 游戏服务器、大型社交应用



## 5 六边形架构（Hexagonal Architecture / Ports and Adapters）

**核心思想**
 系统核心业务逻辑与外部技术细节解耦，通过 Port 接口与 Adapter 适配器实现对接。

**结构**

- 核心业务逻辑（Domain）
- Port 接口定义
- Adapter 实现（如 Web、DB、消息队列）

**优点**

- 高度解耦，可测试性强
- 易于替换技术组件
- 便于业务逻辑重用

**缺点**

- 初学者理解成本高
- 设计较为抽象，非所有项目适合

**适用场景**

- 业务逻辑复杂，变更频繁的系统
- 需要接口稳定性与技术替换灵活性



## 6 事件驱动架构（Event-Driven Architecture, EDA）

**核心思想**
 通过事件通知机制驱动系统交互，组件间解耦，响应式扩展。

**结构**

- 事件生产者
- 事件总线（如 Kafka）
- 事件消费者（订阅处理）

**优点**

- 松耦合，易扩展
- 异步非阻塞，性能高
- 适应复杂业务流转

**缺点**

- 调试困难
- 难以保证一致性
- 事件风暴风险

**适用场景**

- 订单系统、支付系统、IoT
- 微服务间协作



## 7 编排架构（Orchestration Architecture）

**核心思想**
 由中心组件控制多个子服务的调用流程，实现流程控制、异常处理与服务组合。

**结构**

- Orchestrator（控制器）
- Service1 / Service2 / ...
- 编排流程图（可视或代码）

**优点**

- 流程可控、异常可捕捉
- 易于调试与观察
- 服务复用度高

**缺点**

- 中心化架构带来单点风险
- 编排逻辑可能变得复杂难维护

**适用场景**

- 工作流系统
- 微服务流程聚合调用
- 大模型 Agent 链路调度（如 LangGraph）



## 8 CQRS 架构（Command Query Responsibility Segregation）

**核心思想**
 读写职责分离，写操作使用命令模型，读操作使用查询模型，各自优化。

**结构**

- Command Service（写）
- Query Service（读）
- Write Model（聚合根）
- Read Model（DTO、视图表、缓存）

**优点**

- 分离关注点，职责清晰
- 写逻辑清晰，可事务控制
- 读操作高性能、可缓存优化

**缺点**

- 架构复杂度提高
- 数据同步与一致性处理要求高
- 初期开发成本增加

**适用场景**

- 高并发系统（读多写少）
- 业务逻辑复杂且读写模式差异大
- 事件驱动 + 微服务系统